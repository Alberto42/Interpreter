{-# LANGUAGE RankNTypes #-}
module SkelGrammar where

-- Haskell module generated by the BNF converter

import AbsGrammar
import ErrM
import InterpreterMonad
import qualified Data.Map             as Map
import Utils

transIdent :: Ident -> InterpreterMonad Value
transIdent x = case x of
  Ident string -> returnError "not yet implemented"
transProgram :: Program -> InterpreterMonad Value
transProgram x = case x of
  SProgram stmts -> transStmts stmts
transStmts :: Stmts -> InterpreterMonad Value
transStmts x = case x of
  StmtsNull -> return $ VInt 0
  SStmts stmt stmts -> transStmt stmt >> transStmts stmts
transStmt :: Stmt -> InterpreterMonad Value
transStmt x = case x of
  Assign ident exp -> do
    val <- transExp exp
    InterpreterMonad $ \s -> Right (Null, Map.insert ident val s)

  ConstAssign ident exp -> returnError "not yet implemented"
  If exp bracedstmts -> returnError "not yet implemented"
  IfElse exp bracedstmts1 bracedstmts2 -> returnError "not yet implemented"
  For ident exp1 exp2 bracedstmts -> returnError "not yet implemented"
  While exp bracedstmts -> returnError "not yet implemented"
  Break -> returnError "not yet implemented"
  Continue -> returnError "not yet implemented"
  FuncCall ident exp -> returnError "not yet implemented"
  FuncDecl ident1 ident2 bracedstmts -> returnError "not yet implemented"
  Return exp -> returnError "not yet implemented"
  Print parident -> returnError "not yet implemented"
  AssignListElem ident exp1 exp2 -> returnError "not yet implemented"
  GetListSize list -> returnError "not yet implemented"
  AppendListElem ident exp -> returnError "not yet implemented"
  AssignTuple ident tuple -> returnError "not yet implemented"
  SExtract identifiers ident -> returnError "not yet implemented"
transBracedStmts :: BracedStmts -> InterpreterMonad Value
transBracedStmts x = case x of
  SBracedStmts stmts -> returnError "not yet implemented"
transParIdent :: ParIdent -> InterpreterMonad Value
transParIdent x = case x of
  SParIdent ident -> returnError "not yet implemented"
transLiteral :: Literal -> InterpreterMonad Value
transLiteral x = case x of
  LiteralStr string -> returnError "not yet implemented"
  LiteralInt integer -> returnError "not yet implemented"
  LiteralBool boolean -> returnError "not yet implemented"
  LiteralTuple tuple -> returnError "not yet implemented"
transBoolean :: Boolean -> InterpreterMonad Value
transBoolean x = case x of
  BoolTrue -> returnError "not yet implemented"
  BoolFalse -> returnError "not yet implemented"
transExp :: Exp -> InterpreterMonad Value
transExp x = case x of
  ExpList list -> returnError "not yet implemented"
  ExpTuple tuple -> returnError "not yet implemented"
  BoolOr exp1 exp2 -> booleanOp exp1 exp2 "or" (||)
  BoolAnd exp1 exp2 -> booleanOp exp1 exp2 "and" (&&)
  BoolNot exp -> do
    v <- transExp exp
    case v of
      VBoolean b -> return $ VBoolean $ not b
      otherwise -> returnError "Wrong type of not operator"
  BoolIsSmaller exp1 exp2 -> booleanCompOp exp1 exp2 "<" (<) (<)
  BoolSmallerOrEq exp1 exp2 -> booleanCompOp exp1 exp2 "<=" (<=) (<=)
  BoolGreater exp1 exp2 -> booleanCompOp exp1 exp2 ">" (>) (>)
  BoolGreaterOrEq exp1 exp2 -> booleanCompOp exp1 exp2 ">=" (>=) (>=)
  BoolEqual exp1 exp2 -> booleanEqOp exp1 exp2 "==" (==) (==) (==)
  BoolNotEqual exp1 exp2 -> booleanEqOp exp1 exp2 "!=" (/=) (/=) (/=)
  Add exp1 exp2 -> evalInfixOp exp1 exp2
    (\a b -> case (a,b) of
      (VInt i1, VInt i2) -> return $ VInt (i1+i2)
      (VString s1, VString s2) -> return $ VString(s1 ++ s2)
      otherwise -> returnError "Wrong types of + operator")
  IntSub exp1 exp2 -> integerEvalInfixOp exp1 exp2 (-)
  IntMult exp1 exp2 -> integerEvalInfixOp exp1 exp2 (*)
  IntDiv exp1 exp2 -> do
      r <- transExp exp2
      case r of
        VInt 0 -> returnError "Interpreter tried to divide by zero"
        otherwise -> integerEvalInfixOp exp1 exp2 div
  Pare exp -> transExp exp
  IntLit integer -> return $ VInt integer
  BoolLit boolean -> return $ case boolean of
    BoolTrue -> VBoolean True
    BoolFalse -> VBoolean False
  StringLit string -> return $ VString string
  SSIdent ident -> getVariable ident
  GetListElem ident exp -> returnError "not yet implemented"
transLiterals :: Literals -> InterpreterMonad Value
transLiterals x = case x of
  SLitNull -> returnError "not yet implemented"
  SLit literal literals -> returnError "not yet implemented"
  SLitSingle literal -> returnError "not yet implemented"
transIdentifiers :: Identifiers -> InterpreterMonad Value
transIdentifiers x = case x of
  SIdentNull -> returnError "not yet implemented"
  SIdent ident identifiers -> returnError "not yet implemented"
  SIdentSingle ident -> returnError "not yet implemented"
transList :: List -> InterpreterMonad Value
transList x = case x of
  SList literals -> returnError "not yet implemented"
transTuple :: Tuple -> InterpreterMonad Value
transTuple x = case x of
  STuple literals -> returnError "not yet implemented"


evalInfixOp expr1 expr2 op = do
  r1 <- transExp expr1
  r2 <- transExp expr2
  op r1 r2

integerEvalInfixOp :: Exp -> Exp -> (forall a. Integral a => a -> a -> a) -> InterpreterMonad Value
integerEvalInfixOp expr1 expr2 op = do
  r1 <- transExp expr1
  r2 <- transExp expr2
  case (r1,r2) of
    (VInt i, VInt i2) -> return $ VInt (op i i2)
    _ -> returnError "Interpreter expected int values for infix operator"

getVariable :: Ident -> InterpreterMonad Value
getVariable var = InterpreterMonad $ \s ->
  let maybeVal = Map.lookup var s in
  case maybeVal of
    Just val -> Right (val, s)
    _ -> Left "Interpreter tried to get value of non-existent variable"

--booleanCompOp :: Exp -> Exp -> String -> (forall a. Integral a => a -> a -> Bool) -> InterpreterMonad Value
booleanCompOp expr1 expr2 opMsg opInt opStr = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VInt i1, VInt i2) -> return $ VBoolean (opInt i1 i2)
    (VString s1, VString s2) -> return $ VBoolean (opStr s1 s2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")

booleanEqOp expr1 expr2 opMsg opInt opStr opBool = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VInt i1, VInt i2) -> return $ VBoolean (opInt i1 i2)
    (VString s1, VString s2) -> return $ VBoolean (opStr s1 s2)
    (VBoolean b1, VBoolean b2) -> return $ VBoolean (opBool b1 b2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")

booleanOp expr1 expr2 opMsg op = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VBoolean b1, VBoolean b2) -> return $ VBoolean (op b1 b2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")