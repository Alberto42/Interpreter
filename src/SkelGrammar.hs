module SkelGrammar where

-- Haskell module generated by the BNF converter

import AbsGrammar
import ErrM
import InterpreterMonad
import qualified Data.Map             as Map

transIdent :: Ident -> InterpreterMonad Value
transIdent x = case x of
  Ident string -> returnError "not yet implemented"
transProgram :: Program -> InterpreterMonad Value
transProgram x = case x of
  SProgram stmts -> transStmts stmts
transStmts :: Stmts -> InterpreterMonad Value
transStmts x = case x of
  StmtsNull -> return $ VInt 0
  SStmts stmt stmts -> transStmt stmt >> transStmts stmts
transStmt :: Stmt -> InterpreterMonad Value
transStmt x = case x of
  Assign ident exp -> do
    val <- transExp exp
    InterpreterMonad $ \s -> Right (Null, Map.insert ident val s)

  ConstAssign ident exp -> returnError "not yet implemented"
  If boolexp bracedstmts -> returnError "not yet implemented"
  IfElse boolexp bracedstmts1 bracedstmts2 -> returnError "not yet implemented"
  For ident intexp1 intexp2 bracedstmts -> returnError "not yet implemented"
  While boolexp bracedstmts -> returnError "not yet implemented"
  Break -> returnError "not yet implemented"
  Continue -> returnError "not yet implemented"
  FuncCall ident exp -> returnError "not yet implemented"
  FuncDecl ident1 ident2 bracedstmts -> returnError "not yet implemented"
  Return exp -> returnError "not yet implemented"
  Print parident -> returnError "not yet implemented"
  AssignListElem ident intexp exp -> returnError "not yet implemented"
  GetListSize list -> returnError "not yet implemented"
  AppendListElem ident exp -> returnError "not yet implemented"
  AssignTuple ident tuple -> returnError "not yet implemented"
  SExtract identifiers ident -> returnError "not yet implemented"
transBracedStmts :: BracedStmts -> InterpreterMonad Value
transBracedStmts x = case x of
  SBracedStmts stmts -> returnError "not yet implemented"
transParIdent :: ParIdent -> InterpreterMonad Value
transParIdent x = case x of
  SParIdent ident -> returnError "not yet implemented"
transLiteral :: Literal -> InterpreterMonad Value
transLiteral x = case x of
  LiteralStr string -> returnError "not yet implemented"
  LiteralInt integer -> returnError "not yet implemented"
  LiteralBool boolean -> returnError "not yet implemented"
  LiteralTuple tuple -> returnError "not yet implemented"
transBoolean :: Boolean -> InterpreterMonad Value
transBoolean x = case x of
  BoolTrue -> returnError "not yet implemented"
  BoolFalse -> returnError "not yet implemented"
transExp :: Exp -> InterpreterMonad Value
transExp x = case x of
  ExpInt intexp -> transIntExp intexp
  ExpString stringexp -> returnError "not yet implemented"
  ExpBool boolexp -> returnError "not yet implemented"
  ExpList list -> returnError "not yet implemented"
  ExpTuple tuple -> returnError "not yet implemented"
  GetListElem ident intexp -> returnError "not yet implemented"
transIntExp :: IntExp -> InterpreterMonad Value
transIntExp x = case x of
  IntAdd intexp1 intexp2 -> returnError "not yet implemented"
  IntSub intexp1 intexp2 -> returnError "not yet implemented"
  IntMult intexp1 intexp2 -> returnError "not yet implemented"
  IntDiv intexp1 intexp2 -> returnError "not yet implemented"
  IntPare intexp -> returnError "not yet implemented"
  IntLit integer -> return $ VInt integer
  IntIdent ident -> returnError "not yet implemented"
transBoolExp :: BoolExp -> InterpreterMonad Value
transBoolExp x = case x of
  BoolOr boolexp1 boolexp2 -> returnError "not yet implemented"
  BoolAnd boolexp1 boolexp2 -> returnError "not yet implemented"
  BoolNot boolexp -> returnError "not yet implemented"
  BoolIsSmaller intexp1 intexp2 -> returnError "not yet implemented"
  BoolSmallerOrEq intexp1 intexp2 -> returnError "not yet implemented"
  BoolGreater intexp1 intexp2 -> returnError "not yet implemented"
  BoolGreaterOrEq intexp1 intexp2 -> returnError "not yet implemented"
  BoolEqual intexp1 intexp2 -> returnError "not yet implemented"
  BoolEqual2 stringexp1 stringexp2 -> returnError "not yet implemented"
  BoolNotEqual intexp1 intexp2 -> returnError "not yet implemented"
  BoolPare boolexp -> returnError "not yet implemented"
  BoolIdent ident -> returnError "not yet implemented"
  BoolLit boolean -> returnError "not yet implemented"
transStringExp :: StringExp -> InterpreterMonad Value
transStringExp x = case x of
  StringConcat stringexp1 stringexp2 -> returnError "not yet implemented"
  StringIdent ident -> returnError "not yet implemented"
  StringLit string -> returnError "not yet implemented"
transLiterals :: Literals -> InterpreterMonad Value
transLiterals x = case x of
  SLitNull -> returnError "not yet implemented"
  SLit literal literals -> returnError "not yet implemented"
  SLitSingle literal -> returnError "not yet implemented"
transIdentifiers :: Identifiers -> InterpreterMonad Value
transIdentifiers x = case x of
  SIdentNull -> returnError "not yet implemented"
  SIdent ident identifiers -> returnError "not yet implemented"
  SIdentSingle ident -> returnError "not yet implemented"
transList :: List -> InterpreterMonad Value
transList x = case x of
  SList literals -> returnError "not yet implemented"
transTuple :: Tuple -> InterpreterMonad Value
transTuple x = case x of
  STuple literals -> returnError "not yet implemented"

