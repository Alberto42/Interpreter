{-# LANGUAGE RankNTypes #-}
module SkelGrammar where

-- Haskell module generated by the BNF converter

import AbsGrammar
import ErrM
import InterpreterMonad
import qualified Data.Map             as Map
import qualified Data.Sequence as Seq
import Utils


transIdent :: Ident -> InterpreterMonad Value
transIdent x = case x of
  Ident string -> returnError "not yet implemented 1" -- useless ?
transProgram :: Program -> InterpreterMonad StatementValue
transProgram x = case x of
  SProgram stmts -> transStmts stmts
transStmts :: Stmts -> InterpreterMonad StatementValue
transStmts x = case x of
  StmtsNull -> return $ OK
  SStmts stmt stmts -> do
    status <- transStmt stmt
    case status of
      OK ->transStmts stmts
      otherwise -> return status
transStmt :: Stmt -> InterpreterMonad StatementValue
transStmt x =
  case x of
    Assign ident exp -> do
      val <- transExp exp
      setVariable ident val
    ConstAssign ident exp -> returnError "not yet implemented 2"
    If exp bracedstmts -> do
      val <- transExp exp
      case val of
        VBoolean b ->
          if b
            then transBracedStmts bracedstmts
            else return OK
        otherwise -> returnError "wrong condition in if"
    IfElse exp bracedstmts1 bracedstmts2 -> do
      val <- transExp exp
      case val of
        VBoolean b ->
          transBracedStmts $
          if b
            then bracedstmts1
            else bracedstmts2
        otherwise -> returnError "wrong condition in if"
    For ident exp1 exp2 bracedstmts -> do
      val1 <- transExp exp1
      val2 <- transExp exp2
      case (val1, val2) of
        (VInt i1, VInt i2) ->
          if i1 <= i2
            then do
              maybeOriginalIdent <- getVariable ident
              setVariable ident val1
              status <- transBracedStmts bracedstmts
              let nextLoopStepMonad = transStmt $ For ident (IntLit $ i1 + 1) (IntLit i2) bracedstmts
               in case status of
                    OK -> nextLoopStepMonad
                    VBreak -> return OK
                    VContinue -> nextLoopStepMonad
              case maybeOriginalIdent of
                Just val -> setVariable ident val
                Nothing -> removeVariable ident
            else return OK
        otherwise -> returnError "wrong range types in for loop"
    While exp bracedstmts -> do
      val <- transExp exp
      case val of
        VBoolean b ->
          if b
            then do
              status <- transBracedStmts bracedstmts
              let nextLoopStepMonad = transStmt $ While exp bracedstmts
               in case status of
                    OK -> nextLoopStepMonad
                    VBreak -> return OK
                    VContinue -> nextLoopStepMonad
            else return OK
        otherwise -> returnError "wrong condition in while loop"
    Break -> return VBreak
    Continue -> return VContinue
    FuncCall ident exp -> do
      transExp $ FuncCallExp ident exp
      return OK
    FuncDecl ident1 ident2 bracedstmts -> do
      State envDecl storeDecl declDecl <- getState
      let declValue arg =
            let declDecl' = Map.insert ident1 declValue declDecl
              in do
                State envCall storeCall declCall <- getState
                setEnv envDecl
                setDecl declDecl'
                createNewVariable ident2 arg
                status <- transBracedStmts bracedstmts
                State _ newStore _ <- getState
                setEnv envCall
                setDecl declCall
                setStore newStore
                case status of
                  OK -> return Null
                  VReturn v -> return v
                  otherwise -> returnError "Break or continue inside function body"
          newDecl = Map.insert ident1 declValue declDecl
        in
        setDecl newDecl
      return OK
    Return exp -> do
      val <- transExp exp
      return $ VReturn val
    Print parident -> do
      val <- transParExp parident
      printMonad $ case val of
        VInt i -> show i
        VString s -> s
        VBoolean b -> show b
        VList l -> drop 9 $ show l
    AssignListElem ident exp1 exp2 -> do
      i <- getInt exp1
      val2 <- transExp exp2
      list <- getList ident
      if  0 <= i && i < length list
      then
        let newList = Seq.update (fromIntegral i) val2 list
        in
          setVariable ident $ VList newList
      else returnError "out of bounds exception"

    AppendListElem ident exp -> do
      val <- transExp exp
      list <- getList ident
      let newList = list Seq.|> val
        in
        setVariable ident $ VList newList
    AssignTuple ident tuple -> returnError "not yet implemented 14"
    SExtract identifiers ident -> returnError "not yet implemented 15"
transBracedStmts :: BracedStmts -> InterpreterMonad StatementValue
transBracedStmts x = case x of
  SBracedStmts stmts -> transStmts stmts
transParExp :: ParExp -> InterpreterMonad Value
transParExp x = case x of
  SParExp exp -> transExp exp
transLiteral :: Literal -> InterpreterMonad Value
transLiteral x = case x of
  LiteralStr string -> return $ VString string
  LiteralInt integer -> return $ VInt integer
  LiteralBool boolean -> transBoolean boolean
  LiteralTuple tuple -> returnError "not yet implemented 20" -- useless ?
transBoolean :: Boolean -> InterpreterMonad Value
transBoolean x = case x of
  BoolTrue -> return $ VBoolean True
  BoolFalse -> return $ VBoolean False
transExp :: Exp -> InterpreterMonad Value
transExp x = case x of
  ExpList list -> transList list
  ExpTuple tuple -> returnError "not yet implemented 24"
  BoolOr exp1 exp2 -> booleanOp exp1 exp2 "or" (||)
  BoolAnd exp1 exp2 -> booleanOp exp1 exp2 "and" (&&)
  BoolNot exp -> do
    v <- transExp exp
    case v of
      VBoolean b -> return $ VBoolean $ not b
      otherwise -> returnError "Wrong type of not operator"
  BoolIsSmaller exp1 exp2 -> booleanCompOp exp1 exp2 "<" (<) (<)
  BoolSmallerOrEq exp1 exp2 -> booleanCompOp exp1 exp2 "<=" (<=) (<=)
  BoolGreater exp1 exp2 -> booleanCompOp exp1 exp2 ">" (>) (>)
  BoolGreaterOrEq exp1 exp2 -> booleanCompOp exp1 exp2 ">=" (>=) (>=)
  BoolEqual exp1 exp2 -> booleanEqOp exp1 exp2 "==" (==) (==) (==)
  BoolNotEqual exp1 exp2 -> booleanEqOp exp1 exp2 "!=" (/=) (/=) (/=)
  Add exp1 exp2 -> evalInfixOp exp1 exp2
    (\a b -> case (a,b) of
      (VInt i1, VInt i2) -> return $ VInt (i1+i2)
      (VString s1, VString s2) -> return $ VString(s1 ++ s2)
      otherwise -> returnError "Wrong types of + operator")
  IntSub exp1 exp2 -> integerEvalInfixOp exp1 exp2 (-)
  IntMult exp1 exp2 -> integerEvalInfixOp exp1 exp2 (*)
  IntDiv exp1 exp2 -> do
      r <- transExp exp2
      case r of
        VInt 0 -> returnError "Interpreter tried to divide by zero"
        otherwise -> integerEvalInfixOp exp1 exp2 div
  Pare exp -> transExp exp
  IntLit integer -> return $ VInt integer
  BoolLit boolean -> transBoolean boolean
  StringLit string -> return $ VString string
  SSIdent ident -> do
    maybeVal <- getVariable ident
    case maybeVal of
      Just val -> return val
      _ -> returnError "Interpreter tried to get value of non-existent variable"
  GetListElem ident exp -> do
    val <- getInt exp
    list <- getList ident
    return $ Seq.index list (fromIntegral val)
  FuncCallExp ident exp -> do
    val <- transExp exp
    (State _ _ decl) <- getState
    let maybeFunction = Map.lookup ident decl in
      case maybeFunction of
        Just f -> f val
        Nothing -> returnError "Function doesn't exist"
  GetListSize exp -> do
    (VList list) <- transExp exp
    return $ VInt $ toInteger $ length list
transLiterals :: Literals -> InterpreterMonad Value
transLiterals x = case x of
  SLitNull -> return $ VList Seq.empty
  SLit literal literals -> do
    valRight <- transLiterals literals
    valSingleLeft <- transLiteral literal
    case valRight of
      VList valRightL ->
        return $ VList $ (Seq.singleton valSingleLeft) Seq.>< valRightL
      otherwise -> returnError "This shouldn't happened 2"


  SLitSingle literal -> do
    val <- transLiteral literal
    return $ VList $ Seq.singleton val
transIdentifiers :: Identifiers -> InterpreterMonad Value
transIdentifiers x = case x of
  SIdentNull -> returnError "not yet implemented 29"
  SIdent ident identifiers -> returnError "not yet implemented 30"
  SIdentSingle ident -> returnError "not yet implemented 31"
transList :: List -> InterpreterMonad Value
transList x = case x of
  SList literals -> do
    (VList list) <- transLiterals literals
    return $ VList list
transTuple :: Tuple -> InterpreterMonad Value
transTuple x = case x of
  STuple literals -> returnError "not yet implemented 33"


evalInfixOp expr1 expr2 op = do
  r1 <- transExp expr1
  r2 <- transExp expr2
  op r1 r2

integerEvalInfixOp :: Exp -> Exp -> (forall a. Integral a => a -> a -> a) -> InterpreterMonad Value
integerEvalInfixOp expr1 expr2 op = do
  r1 <- transExp expr1
  r2 <- transExp expr2
  case (r1,r2) of
    (VInt i, VInt i2) -> return $ VInt (op i i2)
    _ -> returnError "Interpreter expected int values for infix operator"

getVariable :: Ident -> InterpreterMonad (Maybe Value)
getVariable ident = monad $ \s ->
  let maybePos = Map.lookup ident (env s)
      maybeVal = (maybePos >>= \pos -> Just $ Seq.index (store s) pos  )
  in
  Right (maybeVal, s)

setVariable :: Ident -> Value -> InterpreterMonad StatementValue
setVariable ident val = monad $ \s ->
  case val of
    Null -> Left "Wrong assignment"
    otherwise ->
      let maybePos = Map.lookup ident (env s) in
      case maybePos of
        Just pos ->
          let store' = Seq.update pos val (store s)
          in Right(OK, State (env s) store' (decl s))
        Nothing ->
          let store' = (store s) Seq.|> val in
          let env' = Map.insert ident (length store' - 1) (env s)
          in Right(OK, State env' store' (decl s))

createNewVariable :: Ident -> Value -> InterpreterMonad StatementValue
createNewVariable ident val = monad $ \s ->
  let store' = (store s) Seq.|> val in
  let env' = Map.insert ident (length store' - 1) (env s)
  in Right(OK, State env' store' (decl s))

removeVariable :: Ident -> InterpreterMonad StatementValue
removeVariable ident = monad $ \s -> Right (OK, State (Map.delete ident (env s)) (store s) (decl s) )

--booleanCompOp :: Exp -> Exp -> String -> (forall a. Integral a => a -> a -> Bool) -> InterpreterMonad Value
booleanCompOp expr1 expr2 opMsg opInt opStr = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VInt i1, VInt i2) -> return $ VBoolean (opInt i1 i2)
    (VString s1, VString s2) -> return $ VBoolean (opStr s1 s2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")

booleanEqOp expr1 expr2 opMsg opInt opStr opBool = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VInt i1, VInt i2) -> return $ VBoolean (opInt i1 i2)
    (VString s1, VString s2) -> return $ VBoolean (opStr s1 s2)
    (VBoolean b1, VBoolean b2) -> return $ VBoolean (opBool b1 b2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")

booleanOp expr1 expr2 opMsg op = evalInfixOp expr1 expr2
  (\a b -> case (a,b) of
    (VBoolean b1, VBoolean b2) -> return $ VBoolean (op b1 b2)
    otherwise -> returnError $ "Wrong types of " ++ opMsg ++ " operator")


getList :: Ident -> InterpreterMonad (Seq.Seq Value)
getList ident = do
  maybeList <- getVariable ident
  case maybeList of
    Just value ->
      case value of
        (VList list) -> return $ list
        otherwise -> returnError "Expected list"
    Nothing -> returnError "List doesn't exist"

getInt :: Exp -> InterpreterMonad (Int)
getInt exp = do
  val <- transExp exp
  case val of
    VInt i -> return $ fromIntegral i
    otherwise -> returnError "Expected int"